title: Lab 2
author: Leedy

# Lab 2

## Introduction

这部分主要在讲 git 的用法。由于我比较熟练所以看了没什么感觉。另外，可以用 `git cherry-pick` 来将 lab 1 的修改应用到 lab 2 上。

## Part 1: Physical Page Management

> **Exercise 1.** In the file `kern/pmap.c`, you must implement code for the following functions (probably in the order given).
>
> `boot_alloc()`
> `mem_init()` (only up to the call to `check_page_free_list(1)`)
> `page_init()`
> `page_alloc()`
> `page_free()`
>
> `check_page_free_list()` and `check_page_alloc()` test your physical page allocator. You should boot JOS and see whether `check_page_alloc()` reports success. Fix your code so that it passes. You may find it helpful to add your own `assert()`s to verify that your assumptions are correct.

Lab2 不像 lab1 给了大量的提示，几乎没法从 lab 的提示里找到应该如何写。这时候仔细读代码和代码里的注释就非常有必要了。

另外，这一部分由于虚存机制已经打开，因此内存寻址经常在虚存地址与物理内存地址间跳转，这时候一定要搞清楚 `entrypgdir.c` 里的内存布局。

### `boot_alloc()`

首先，JOS 启动后的调用顺序是

	init.c#i386_init -> pmap.c#mem_init -> boot_alloc
	
可以看到，`boot_alloc` 只在启动过程中被调用一次，分配的内存空间用来存放页目录。

再去看 `boot_alloc` 函数的注释，于是 `boot_alloc` 干的事情就很清楚了：通过最简单的方法在内存中找到一块地方分配出去。

然后看到 `nextfree`，`ROUNDUP` 是内存对齐的宏，我们直接跳过。`nextfree` 初始化为 `end`，然后 'end' is a magic symbol automatically generated by the linker。通过 `readelf` 可以看出，`end` 指向的地址是 0xf011a990 （不一定），于是基本可以确定，`end` 之上的内存空间是可以使用的。那么最高可用的地址是什么呢？注意此时的 `%cr3` 还停留在 `entry_pgdir`，因此只有 4M 的内存地址可用，即内存最多只能用到 0xf03fffff，过度分配时要报 panic。

### `mem_init()`

`mem_init()` 是 JOS 启动时调用的函数，这个函数干的事情很多，（暂时）主要有

1. 调用 `i386_detect_memory`。
2. 创建页目录（也是第一个页表）`kern_pgdir`。
3. 创建 `pages` 结构。
4. 调用 `page_init` 初始化 `pages`。

一开始我没有搞清楚 `pages` 和 `kern_pgdir` 的区别，后来意识到 `PageInfo` 存放的是物理内存的信息，而 `pde_t` 是页表（页目录）。使用 `page2pa` 与 `pa2page` 两个函数在 `PageInfo` 与物理内存间相互转换。

这里需要写的代码很简单，只要用 `boot_alloc` 分配 `pages` 的内存，再用 `memset` 清空即可。

### `page_init()`

这一部分注释也讲的很清楚，原来的代码是将所有 page 都放在 `page_free_list` 里，这是不对的，因为

1. `page[0]` 存放了 real-mode IDT and BIOS structures，不能使用。
2. IO hole `[IOPHYSMEM, EXTPHYSMEM)` 不能用。
3. Kernel 使用的空间不能用，这一部分在 `[EXTPHYSMEM, PADDR(boot_alloc(0)))`。

其中，2和3可以合并。

所以要把它们挖掉，我使用的方法是先把它们的 `pp_ref` 标记为1，然后在循环时跳过它们。

### `page_alloc()`

有了上面的基础，这边的代码很好写：取出 `page_free_list` 第一个即可。于是我就没有仔细读注释，最后粗了大事……

注释里写的很清楚，「Returns NULL if out of free memory」。结果我没有做判断，于是每次都会访问空指针。由于现在还没有设置中断向量表，所以一旦出错 QEMU 就会重启，于是花了很久 debug。

### `page_free()`

这个函数直接将 page 放入 `page_free_list` 即可。

## Part 2: Virtual Memory

> **Exercise 2.** Look at chapters 5 and 6 of the Intel 80386 Reference Manual, if you haven't done so already. Read the sections about page translation and page-based protection closely (5.2 and 6.4). We recommend that you also skim the sections about segmentation; while JOS uses paging for virtual memory and protection, segment translation and segment-based protection cannot be disabled on the x86, so you will need a basic understanding of it.

讲的基本都是操统课上讲过的。反倒是下面的寻址方式的图比较直观。

### Virtual, Linear, and Physical Addresses

	           Selector  +--------------+         +-----------+
	          ---------->|              |         |           |
	                     | Segmentation |         |  Paging   |
	Software             |              |-------->|           |---------->  RAM
	            Offset   |  Mechanism   |         | Mechanism |
	          ---------->|              |         |           |
	                     +--------------+         +-----------+
	            Virtual                   Linear                Physical

> **Exercise 3.** While GDB can only access QEMU's memory by virtual address, it's often useful to be able to inspect physical memory while setting up virtual memory. Review the QEMU monitor commands from the lab tools guide, especially the xp command, which lets you inspect physical memory. To access the QEMU monitor, press Ctrl-a c in the terminal (the same binding returns to the serial console).
>
> Use the xp command in the QEMU monitor and the x command in GDB to inspect memory at corresponding physical and virtual addresses and make sure you see the same data.
>
> Our patched version of QEMU provides an info pg command that may also prove useful: it shows a compact but detailed representation of the current page tables, including all mapped memory ranges, permissions, and flags. Stock QEMU also provides an info mem command that shows an overview of which ranges of virtual memory are mapped and with what permissions.

我用的是仓库安装的 QEMU，因此只能使用 `info mem` 来查看页表。

下面讨论了虚拟内存和物理内存的在内核中的访问。由于 MMU 已经打开，所以内核也无法直接访问物理地址，只能通过 0xf0000000 以上的虚拟地址来访问。这也是 JOS 只支持 256MB 的原因。
 
> **Question 1.** that the following JOS kernel code is correct, what type should variable `x` have, `uintptr_t` or `physaddr_t`?
>
> 		mystery_t x;
> 		char* value = return_a_pointer();
> 		*value = 10;
> 		x = (mystery_t) value;

由于这里 dereference 了 `value`，所以显然是虚拟内存指针，即 `uintptr_t`。

### Reference counting

这一段讲了 `struct PageInfo` 中引用计数的重要性。

### Page Table Management

> **Exercise 4.** In the file `kern/pmap.c`, you must implement code for the following functions.
>
>		pgdir_walk()
>		boot_map_region()
>		page_lookup()
>		page_remove()
>		page_insert()
>
> `check_page()`, called from `mem_init()`, tests your page table management routines. You should make sure it reports success before proceeding.

### `pgdir_walk()`

这个函数其实是最重要的，因为其他几个函数都必须先找到 PTE 才能进一步操作。

要想找到一个 va 对应的 PTE，首先必须要找到 PDE。注意 `pgdir` 指向第一个 PDE，因此 va 对应的 PDE 是 `pgdir + PDX(va)` 而不是 `pgdir[PDX(va)]`。

找到 PDE 后，可能对应的页表不存在，如果 `create` 为1，则调用 `page_alloc(1)` 创建页表、用 `page2pa` 获取新分配的页的地址。另外，由于页表里存放的地址是物理地址，因此需要用 `KADDR` 转成内核虚拟地址来返回。

### `boot_map_region()`

这个函数比较简单，只要调用 `pgdir_walk()` 找到 PTE，然后将 PTE 的内容填充为 `pa` 即可。需要注意的是不用增加 `pp_ref`。另外，这个函数非常不安全，因为它什么也没有检测。

### `page_lookup()`

与上面相似，先找到 PTE，然后取出 `pa`，然后用 `pa2page` 即可。容易出错的地方是 `pte` 可能为 `NULL`，所以直接 dereference 可能会出错。

### `page_remove()`

提示说的非常清楚

1. 用 `page_lookup` 取出 page，顺便还把 PTE 给取出来了。
2. 用 `page_decref` 减 `pp_ref`、调用 `page_free`。
3. 将 PTE 清空。
4. 调用 `tlb_invalidate` 。

### `page_insert()`

前面写了那么多之后，其实这里就有好多种写法了，例如可以直接调用 `page_lookup` 而不是 `pgdir_walk` + `page_remove`，不过如果页表不存在的话还需要调用 `pgdir_walk` 创建……

不过这里有个坑，就是如果将一个已经 map 过的 page 再次 map 到相同的地址就会出错，原因是 `page_remove()` 时把这页释放掉了，于是768行左右的 `assert(!page_alloc(0))` 就报错。最简单的解决方法是将 `pp->pp_ref += 1` 移动到 `page_remove` 之上。

## Part 3: Kernel Address Space

第三部分就是实现 `memlayout.h` 里的设计，主要用到的函数是上一部分写的 `boot_map_region()`。

### Permissions and Fault Isolation

`ULIM` 以上是 Kernel RW 的，`[UTOP,ULIM)` 是 User R- 的，`UTOP` 以下是 User RW 的。

### Initializing the Kernel Address Space

> **Exercise 5.** Fill in the missing code in `mem_init()` after the call to `check_page()`.
>
> Your code should now pass the `check_kern_pgdir()` and `check_page_installed_pgdir()` checks.

这个 exercise 就是写几个 `boot_map_region`，但要弄清楚虚拟地址、物理地址、权限三个东西。

1. Map 'pages' read-only by the user at linear address UPAGES. 由于 pages itself 本身就在 `ULIM` 之上，因此只需要 map 到 `UPAGES` 即可。要注意的是 `UPAGES` 是虚拟地址，物理地址是 `PADDR(pages)`。
2. Use the physical memory that 'bootstack' refers to as the kernel stack. 注意看注释，这段内存的开始地址是 `PADDR(bootstack)`，需要 map 到 `KSTACKTOP - KSTKSIZE` 处。
3. Map all of physical memory at KERNBASE. 这里需要将从 0 开始 256MB 内存全部 map 到 `KERNBASE` 处。

到这里，所有的 check 函数就都可以通过了。

> **Question 2.** What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:


|   Entry   | Base Virtual Address |  Points to (logically):  |
|-----------|----------------------|--------------------------|
| 960-1023  |  0xf0000000          | 从0开始256MB内存          |
|  959      |  0xefc00000（一部分）  | entry.S 里的 bootstack   |
|  957      |  0xef400000          | 用户只读的页表             |
|  956      |  0xef000000          | 用户只读的物理内存信息       |

除了刚刚的三个外，还需要注意的是 `pmap.c` 141 行 

	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

将页表自映射到 `UVPT` 的位置。

> **Question 3.** We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel's memory? What specific mechanisms protect the kernel memory?

因为我们在页表与页目录里加了权限设置。这是 MMU 提供的机制。

> **Question 4.** What is the maximum amount of physical memory that this operating system can support? Why?

最大只支持 256MB 的内存，因为在 `page_alloc` 时我们需要调用 `page2kva`，而内核虚拟内存最大只有 256MB。

> **Question 5.** How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?

最少需要一个页目录与一堆 `PageInfo`，因此当内存是 256MB 时，占用 `4k + 256M / 4096 * sizeof(PageInfo) = 4k + 512k = 516k` 的内存。

> **Question 6.** Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?

1. 在 `entry.S` 68行 `jmp	*%eax` 切换到高地址。
2. 因为 `entrypgdir.c` 里将 0 开始的内存和 0xf0000000 的内存都映射到了 0 上，因此仍然可以通过低地址访问。
3. 因为后面的 `call	i386_init` 使用间接寻址方式，如果不切换到高地址那么后面所有的 data 段解析都会出错。

> *Challenge!* We consumed many physical pages to hold the page tables for the KERNBASE mapping. Do a more space-efficient job using the PTE_PS ("Page Size") bit in the page directory entries. This bit was not supported in the original 80386, but is supported on more recent x86 processors. You will therefore have to refer to Volume 3 of the current Intel manuals. Make sure you design the kernel to use this optimization only on processors that support it!

这题不是很难，最主要的是读 Intel 手册，得知使用 `cpuid` 指令可以获取 CPU 信息，看 edx 的第三位即可知道是否支持 `PTE_PS`。于是在 `i386_detect_memory` 里添加检测代码，在 `boot_map_region` 中判断如果 `size` 是 4M 的整数倍，那么就使用 `PTE_PS`。不过后果就是 `check_kern_pgdir` 无法通过检测。

