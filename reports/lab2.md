title: Lab 2
author: Leedy

# Lab 2

## Introduction

这部分主要在讲 git 的用法。由于我比较熟练所以看了没什么感觉。另外，可以用 `git cherry-pick` 来将 lab 1 的修改应用到 lab 2 上。

## Part 1: Physical Page Management

> Exercise 1. In the file `kern/pmap.c`, you must implement code for the following functions (probably in the order given).
>
> `boot_alloc()`
> `mem_init()` (only up to the call to `check_page_free_list(1)`)
> `page_init()`
> `page_alloc()`
> `page_free()`
>
> `check_page_free_list()` and `check_page_alloc()` test your physical page allocator. You should boot JOS and see whether `check_page_alloc()` reports success. Fix your code so that it passes. You may find it helpful to add your own `assert()`s to verify that your assumptions are correct.

Lab2 不像 lab1 给了大量的提示，几乎没法从 lab 的提示里找到应该如何写。这时候仔细读代码和代码里的注释就非常有必要了。

另外，这一部分由于虚存机制已经打开，因此内存寻址经常在虚存地址与物理内存地址间跳转，这时候一定要搞清楚 `entrypgdir.c` 里的内存布局。

### `boot_alloc()`

首先，JOS 启动后的调用顺序是

	init.c#i386_init -> pmap.c#mem_init -> boot_alloc
	
可以看到，`boot_alloc` 只在启动过程中被调用一次，分配的内存空间用来存放页目录。

再去看 `boot_alloc` 函数的注释，于是 `boot_alloc` 干的事情就很清楚了：通过最简单的方法在内存中找到一块地方分配出去。

然后看到 `nextfree`，`ROUNDUP` 是内存对齐的宏，我们直接跳过。`nextfree` 初始化为 `end`，然后 'end' is a magic symbol automatically generated by the linker。通过 `readelf` 可以看出，`end` 指向的地址是 0xf011a990 （不一定），于是基本可以确定，`end` 之上的内存空间是可以使用的。那么最高可用的地址是什么呢？注意此时的 `%cr3` 还停留在 `entry_pgdir`，因此只有 4M 的内存地址可用，即内存最多只能用到 0xf03fffff，过度分配时要报 panic。

### `mem_init()`

`mem_init()` 是 JOS 启动时调用的函数，这个函数干的事情很多，（暂时）主要有

1. 调用 `i386_detect_memory`。
2. 创建页目录（也是第一个页表）`kern_pgdir`。
3. 创建 `pages` 结构。
4. 调用 `page_init` 初始化 `pages`。

一开始我没有搞清楚 `pages` 和 `kern_pgdir` 的区别，后来意识到 `PageInfo` 存放的是物理内存的信息，而 `pde_t` 是页表（页目录）。使用 `page2pa` 与 `pa2page` 两个函数在 `PageInfo` 与物理内存间相互转换。

这里需要写的代码很简单，只要用 `boot_alloc` 分配 `pages` 的内存，再用 `memset` 清空即可。

### `page_init()`

这一部分注释也讲的很清楚，原来的代码是将所有 page 都放在 `page_free_list` 里，这是不对的，因为

1. `page[0]` 存放了 real-mode IDT and BIOS structures，不能使用。
2. IO hole `[IOPHYSMEM, EXTPHYSMEM)` 不能用。
3. Kernel 使用的空间不能用，这一部分在 `[EXTPHYSMEM, PADDR(boot_alloc(0)))`。

其中，2和3可以合并。

所以要把它们挖掉，我使用的方法是先把它们的 `pp_ref` 标记为1，然后在循环时跳过它们。

### `page_alloc()`

有了上面的基础，这边的代码很好写：取出 `page_free_list` 第一个即可。于是我就没有仔细读注释，最后粗了大事……

注释里写的很清楚，「Returns NULL if out of free memory」。结果我没有做判断，于是每次都会访问空指针。由于现在还没有设置中断向量表，所以一旦出错 QEMU 就会重启，于是花了很久 debug。

### `page_free()`

这个函数直接将 page 放入 `page_free_list` 即可。

## Part 2: Virtual Memory





